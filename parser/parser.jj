PARSER_BEGIN(MiniJavaParser)
package parser;
import java.util.ArrayList;
import syntax.*;
import main.CompileError;

public class MiniJavaParser{}
PARSER_END(MiniJavaParser)

// Lexical Stuff

TOKEN : {
	< IF:	"if">				//  Keywords
	| < ELSE: "else" >
	| < CLASS: "class" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >
	| < VOID: "void" >
	| < MAIN: "main" >
	| < STRING: "String" >
	| < EXTENDS: "extends" >
	| < RETURN: "return" >
	| < INT: "int" >
	| < BOOLEAN: "boolean" >
	| < WHILE: "while" >
	| < TRUE: "true" >
	| < FALSE: "false" >
	| < THIS: "this" >
	| < NEW: "new" >
	| < LENGTH: "length" >
	| < PRINTLN: "System.out.println" >
	| < AND: "&&" >				// Operators
	| < LESSTHAN: "<" >
	| < PLUS: "+" >
	| < MINUS: "-" >
	| < MULT: "*" >
	| < NOT: "!" >
	| < DOT: "." >
	| < GETS: "=" >
	| < LBRACE: "{" >			// Seperators
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
	| < RBRACKET: "]" >
	| < LPAREN: "(" >
	| < RPAREN: ")" >
	| < SEMICOLON: ";" >
	| < COMMA: "," >
	| < IDENTIFIER: (<LETTER>) ("_" | <LETTER> | <DIGIT>)* >
	| < INTEGER_LITERAL: (<DIGIT>)+ >
	| < #LETTER: ["a" - "z", "A" - "Z"] >
	| < #DIGIT: ["0" - "9"] >
	| < INVALID: (~[ "\t", " ", "\n", "\r"]) >
}

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| "/*": COMMENT 
}

< COMMENT > SKIP: {
	< ~[] >
	| "*/": DEFAULT
}

// Program expansions
Program JProgram():
{ MainClass m; ArrayList<ClassDecl> cl = new ArrayList<ClassDecl>(); }
{	
	try {
		m = JMainClass() ( cl = JClassDeclList() )? <EOF>
		{ return new Program(m, cl); }
	} catch(ParseException e) {
		syntax_error(e);
		return null;
	}
}

MainClass JMainClass():
{ Identifier cn; Identifier arg; Statement s; }
{
	"class" cn = JIdentifier() "{" 
	"public" "static" "void" "main" 
	"(" "String" "[" "]" arg = JIdentifier() ")"
	"{" s = JStatement() "}" "}"
	{ return new MainClass(cn, arg, s); }
}

ArrayList<ClassDecl> JClassDeclList():
{ ClassDecl cd;	ArrayList<ClassDecl> cl = new ArrayList<ClassDecl>(); }
{
	cd = JClassDecl() { cl = new ArrayList<ClassDecl>(); cl.add(cd); }
	( cd = JClassDecl() { cl.add(cd); } )*
	{ return cl; }
}

ClassDecl JClassDecl():
{ ClassDecl cd; }
{
	LOOKAHEAD(3) cd = JExtendedClassDecl() 
	{ return cd; }
	| 
	cd = JRootClassDecl() 
	{ return cd; }
}

SimpleClassDecl JRootClassDecl():
{ Identifier cn; ArrayList<VarDecl> vl = new ArrayList<VarDecl>(); ArrayList<MethodDecl> ml = new ArrayList<MethodDecl>(); }
{
	"class" cn = JIdentifier() 
	"{" ( vl = JVarDeclList() )? ( ml = JMethodDeclList() )? "}"
	{ return new SimpleClassDecl(cn, vl, ml); }
}

ExtendingClassDecl JExtendedClassDecl():
{ Identifier cn; Identifier scn; ArrayList<VarDecl> vl = new ArrayList<VarDecl>(); ArrayList<MethodDecl> ml = new ArrayList<MethodDecl>(); }
{
	"class" cn = JIdentifier() "extends" scn = JIdentifier() 
	"{" ( vl = JVarDeclList() )? ( ml = JMethodDeclList() )? "}"
	{ return new ExtendingClassDecl(cn, scn, vl, ml); }
}

ArrayList<VarDecl> JVarDeclList():
{ VarDecl vd; ArrayList<VarDecl> vl = new ArrayList<VarDecl>(); }
{
	vd = JVarDecl() { vl = new ArrayList<VarDecl>(); vl.add(vd); }
	( LOOKAHEAD(2) vd = JVarDecl() { vl.add(vd); } )*
	{ return vl; }
}

VarDecl JVarDecl():
{ Type t; Identifier i; }
{
	t = JType() i = JIdentifier() ";"
	{ return new VarDecl(t, i); }
}

ArrayList<MethodDecl> JMethodDeclList():
{ MethodDecl md; ArrayList<MethodDecl> ml = new ArrayList<MethodDecl>(); }
{
	md = JMethodDecl() { ml = new ArrayList<MethodDecl>(); ml.add(md); }
	( md = JMethodDecl() { ml.add(md); } )*
	{ return ml; }
}

// Method declaration expansions
MethodDecl JMethodDecl():
{ 
	Type t; 
	Identifier i; 
	Expression e;
	ArrayList<Formal> fl = new ArrayList<Formal>(); 
	ArrayList<VarDecl> vl = new ArrayList<VarDecl>(); 
	ArrayList<Statement> sl = new ArrayList<Statement>(); 
}
{
	"public" t = JType() i = JIdentifier() "(" ( fl = JParamDeclList() )? ")" "{"
	( LOOKAHEAD(JVarDeclList()) vl = JVarDeclList() )? ( sl = JStatementList() )?
	"return" e = JExpression() ";" "}"
	{ return new MethodDecl(t, i, fl, vl, sl, e); }
}

ArrayList<Formal> JParamDeclList():
{ Formal f; ArrayList<Formal> fl = new ArrayList<Formal>(); }
{
	f = JParamDecl() { fl = new ArrayList<Formal>(); fl.add(f); } 
	( f = JParamDeclListTail() { fl.add(f); } )*
	{ return fl; }
}

Formal JParamDeclListTail():
{ Formal f; }
{
	"," f = JParamDecl()
	{ return f; }
}

Formal JParamDecl():
{ Type t; Identifier i; }
{
	t = JType() i = JIdentifier()
	{ return new Formal( t, i); }
}

Type JType():
{ Token t; }
{
	LOOKAHEAD(3) "int" "[" "]" { return Type.THE_INT_ARRAY_TYPE; }
	| "boolean" { return Type.THE_BOOLEAN_TYPE; }
	| "int"	{ return new IntegerType(); } // Use the static variable in Type class instead>
	| t = <IDENTIFIER> { return new IdentifierType(t.beginLine, t.beginColumn, t.image); }
}

ArrayList<Statement> JStatementList():
{ Statement s; ArrayList<Statement> sl = new ArrayList<Statement>(); }
{
	s = JStatement() { sl = new ArrayList<Statement>(); sl.add(s); }
	( s = JStatement() { sl.add(s); } )*
	{ return sl; }
}

// Statement expansions
Statement JStatement():
{ Statement s; }
{
	try {
		(
		s = JBlock() { return s; }
		| s = JIfStatement() { return s; } 
		| s = JWhileStatement() { return s; }
		| s = JPrintCall() { return s; }
		| LOOKAHEAD(2) s = JAssignment() { return s; }
		| s = JArrayAssignment() { return s; }
		)
	} catch(ParseException e) {
		syntax_error(e);
		skip_to_expected(e.expectedTokenSequences);
		return new Block(new ArrayList<Statement>());
	}
}

Block JBlock():
{ ArrayList<Statement> sl = new ArrayList<Statement>(); }
{	try {
		"{" ( sl = JStatementList() )? "}"
		{ return new Block(sl); }
	} catch(ParseException e){
		syntax_error(e);
		skip_to_expected(e.expectedTokenSequences);
		return new Block(new ArrayList<Statement>());
	}
}

If JIfStatement():
{ Token t; Expression e; Statement s1; Statement s2; }
{/*
	LOOKAHEAD(IfElseStatement()) IfElseStatement()
	| IfThenStatement()	
}

void IfThenStatement():
{}
{
	"if" "(" Expression() ")" Statement()
}

void IfElseStatement():
{}
{*/	
	t = <IF> "(" e = JExpression() ")" s1 = JStatement() "else" s2 = JStatement()
	{ return new If(t.beginLine, t.beginColumn, e, s1, s2); } // Is this the right token position?
}

While JWhileStatement():
{ Token t; Expression e; Statement s; }
{
	t = <WHILE> "(" e = JExpression() ")" s = JStatement()
	{ return new While(t.beginLine, t.beginColumn, e, s); }
}

Print JPrintCall():
{ Token t; Expression e; }
{
	t = <PRINTLN> "(" e = JExpression() ")" ";"
	{ return new Print(t.beginLine, t.beginColumn, e); }
}

Assign JAssignment():
{ Token t; Identifier i; Expression e; }
{
	i = JIdentifier() t = <GETS> e = JExpression() ";"
	{ return new Assign(t.beginLine, t.beginColumn, i, e); } // Do I need to provide pos here>
}

ArrayAssign JArrayAssignment():
{ Token t; Identifier i; Expression ie; Expression ae; }
{
	i = JIdentifier() "[" ie = JExpression() "]" t = <GETS> ae = JExpression() ";"
	{ return new ArrayAssign(t.beginLine, t.beginColumn, i, ie, ae); }
}

// Expression expansions
Expression JExpression():
{ Expression e; }
{
	LOOKAHEAD(JSubExpression() "&&") e = JAndExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "<") e = JCompareExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "+") e = JPlusExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "-") e = JMinusExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "*") e = JMultExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "[") e = JArrayLookupExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "." "length") e = JLengthExpr() { return e; }
	| LOOKAHEAD(JSubExpression() "." JIdentifier() "(" ) e = JFunctionCall() { return e; }
	| e = JSubExpression() { return e; }
}

And JAndExpr():
{ Token t; Expression e1; Expression e2; }
{
	e1 = JSubExpression() t = <AND> e2 = JSubExpression()
	{ return new And(t.beginLine, t.beginColumn, e1, e2); }
}

LessThan JCompareExpr():
{ Token t; Expression e1; Expression e2; }
{
	e1 = JSubExpression() t = <LESSTHAN> e2 = JSubExpression()
	{ return new LessThan(t.beginLine, t.beginColumn, e1, e2); }
}

Plus JPlusExpr():
{ Token t; Expression e1; Expression e2; }
{
	e1 = JSubExpression() t = <PLUS> e2 = JSubExpression()
	{ return new Plus(t.beginLine, t.beginColumn, e1, e2); }
}

Minus JMinusExpr():
{ Token t; Expression e1; Expression e2; }
{	e1 = JSubExpression() t = <MINUS> e2 = JSubExpression()
	{ return new Minus(t.beginLine, t.beginColumn, e1, e2); }
}

Times JMultExpr():
{ Token t; Expression e1; Expression e2; }
{
	e1 = JSubExpression() t = <MULT> e2 = JSubExpression()
	{ return new Times(t.beginLine, t.beginColumn, e1, e2); }
}

ArrayLookup JArrayLookupExpr():
{ Token t; Expression e; Expression ie; }
{
	e = JSubExpression() t = <LBRACKET> ie = JSubExpression() <RBRACKET>
	{ return new ArrayLookup(t.beginLine, t.beginColumn, e, ie); }
}

ArrayLength JLengthExpr():
{ Token t; Expression e; }
{
	e = JSubExpression() t = <DOT> "length"
	{ return new ArrayLength(t.beginLine, t.beginColumn, e); }
}

Call JFunctionCall():
{ Token t; Expression e; Identifier i; ArrayList<Expression> el = new ArrayList<Expression>(); }
{// Does this use the identifier type class? Probably not.
	e = JSubExpression() "." i = JIdentifier() t = <LPAREN> ( el = JMethodParams() )? <RPAREN>
	{ return new Call(t.beginLine, t.beginColumn, e, i, el); }
}

ArrayList<Expression> JMethodParams():
{ Expression e; ArrayList<Expression> el = new ArrayList<Expression>(); }
{
	e = JExpression() { el = new ArrayList<Expression>(); el.add(e); }
	( e = JMethodParamsTail() { el.add(e); }  )*
	{ return el; }
}

Expression JMethodParamsTail():
{ Expression e; }
{
	"," e = JExpression() { return e; }
}

Expression JSubExpression():
{ Token t; Identifier i; IdentifierExp ie; Expression e; }
{
	t = <INTEGER_LITERAL> 
	{ return new IntegerLiteral(t.beginLine, t.beginColumn, Integer.parseInt(t.image));}
	| t = <TRUE> { return new True(t.beginLine, t.beginColumn); }
	| t = <FALSE> { return new False(t.beginLine, t.beginColumn); }
	| t = <THIS> { return new This(t.beginLine, t.beginColumn); }
	| LOOKAHEAD(2) e = JNewArray() { return e; } 
	| t = <NEW> i = JIdentifier() "(" ")" { return new NewObject(t.beginLine, t.beginColumn, i); }
	| t = <NOT> e = JExpression() { return new Not(t.beginLine, t.beginColumn, e); }
	| "(" e = JExpression() ")" { return e; } // is this correct?
	| ie = JIdentifierExp() { return ie; }
}

IdentifierExp JIdentifierExp():
{ Token t; }
{
	t = <IDENTIFIER>
	{ return new IdentifierExp(t.beginLine, t.beginColumn, t.image); }
}

Identifier JIdentifier():
{ Token t; }
{
	t = <IDENTIFIER>
	{ return new Identifier(t.beginLine, t.beginColumn, t.image); }
}

NewArray JNewArray():
{ Token t; Expression e; }
{
	t = <NEW> "int" "[" e = JExpression() "]" 
	{ return new NewArray(t.beginLine, t.beginColumn, e); }
}

JAVACODE
void syntax_error(ParseException e){
	Token t = e.currentToken.next;
	int exp = -1;
	
	for(int i = 0; exp == -1 && i < e.expectedTokenSequences.length; i++)
		for(int j = 0; exp == -1 && j < e.expectedTokenSequences[i].length; j++)
			exp = e.expectedTokenSequences[i][j];
	if (exp != -1)
		CompileError.printError(t.beginLine, t.beginColumn,
			String.format("Syntax Error: expecting a %s\n", e.tokenImage[exp]));
	else
		CompileError.printError(t.beginLine, t.beginColumn, "Syntax Error: unknown");
}

JAVACODE
void skip_to_matching_brace(){
	Token t;
	int depth = 1;
	while (true) {
		t = getToken(1);
		if(t.kind == LBRACE) depth++;
		if(t.kind == RBRACE) {
			depth--;
			if(depth == 0) break;
		}
		if(t.kind == EOF) break;
		t = getNextToken();
	}
}

JAVACODE
void skip_to_kind(int kind) {
	Token t;
	do {
		t = getNextToken();
	} while (t.kind != kind && t.kind != EOF);
}

JAVACODE
void skip_to_expected(int [][] expected){
	Token t;
	do {
		t = getNextToken();
		for (int i = 0; i < expected.length; i++)
			if(t.kind == EOF || t.kind == expected[i][0])
				return;
	} while(true);
}
